
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>forecaster.strategy &#8212; forecaster 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for forecaster.strategy</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; This module provides the `Strategy` class and subclasses, which</span>
<span class="sd">define contribution and withdrawal strategies and associated flags. &quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">decimal</span> <span class="k">import</span> <span class="n">Decimal</span>
<span class="kn">from</span> <span class="nn">forecaster</span> <span class="k">import</span> <span class="n">Money</span>

<span class="c1"># This module is only a few lines over the 1000 line limit. We could</span>
<span class="c1"># reorganize this into 3-5 separate files, but for now these classes</span>
<span class="c1"># are closely-related enough that we might as well keep them together.</span>
<span class="c1"># If this family grows much more then we&#39;ll need to look at splitting</span>
<span class="c1"># them up - perhaps into strategy_base (for metaclass/decorator),</span>
<span class="c1"># strategy_transaction (for ContributionStrategy, WithdrawalStrategy,</span>
<span class="c1"># and TransactionStrategy), strategy_allocation (for</span>
<span class="c1"># AllocationStrategy), and strategy_debt_payment (for</span>
<span class="c1"># DebtPaymentStrategy).</span>
<span class="c1"># pylint: disable=too-many-lines</span>


<div class="viewcode-block" id="strategy_method"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.strategy_method">[docs]</a><span class="k">def</span> <span class="nf">strategy_method</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A decorator for strategy methods, used by Strategy subclasses</span>

<span class="sd">    Methods decorated with this decorator will be automatically added</span>
<span class="sd">    to the dict `strategies`, which is an attribute of the subclass.</span>
<span class="sd">    This happens at class definition time; you need to manually register</span>
<span class="sd">    strategy methods that are added dynamically.</span>

<span class="sd">    Example:</span>
<span class="sd">        class ExampleStrategy(Strategy):</span>
<span class="sd">            @strategy_method(&#39;method key&#39;)</span>
<span class="sd">            def _strategy_method(self):</span>
<span class="sd">                return</span>

<span class="sd">        ExampleStrategy.strategies[&#39;method key&#39;] == \</span>
<span class="sd">            ExampleStrategy._strategy_method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Decorator returned by strategy_method.</span>

<span class="sd">        Adds strategy_key attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">function</span><span class="o">.</span><span class="n">strategy_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">function</span>
    <span class="k">return</span> <span class="n">decorator</span></div>


<div class="viewcode-block" id="StrategyType"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.StrategyType">[docs]</a><span class="k">class</span> <span class="nc">StrategyType</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A metaclass for Strategy classes.</span>

<span class="sd">    This metaclass inspects the class for any @strategy(key)-decorated</span>
<span class="sd">    methods and generates a `strategies` dict of {key, func} pairs. This</span>
<span class="sd">    `strategies` dict is then accessible from the class interface.</span>

<span class="sd">    NOTE: One side-effect of this approach is that strategy methods are</span>
<span class="sd">    collected only once, at definition time. If you want to add a</span>
<span class="sd">    strategy to a class later, you&#39;ll need to manually add it to the</span>
<span class="sd">    subclass&#39;s `strategies` dict.</span>
<span class="sd">    TODO: Add static class methods to Strategy to register/unregister</span>
<span class="sd">    strategy methods? (consider using signature `(func [, key])`)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># First, build the class normally...</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># ... then add a `strategies` dict by looking up every attribute</span>
        <span class="c1"># that has a `strategy_key` attribute of its own.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">strategies</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strategy_key</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmembers</span><span class="p">(</span>
                <span class="bp">cls</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;strategy_key&#39;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">}</span></div>


<span class="c1"># pylint: disable=too-few-public-methods</span>
<div class="viewcode-block" id="Strategy"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.Strategy">[docs]</a><span class="k">class</span> <span class="nc">Strategy</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">StrategyType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; An abstract callable class for determining a strategy.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strategy (str, func): Either a string corresponding to a</span>
<span class="sd">            particular strategy or an instance of the strategy itself.</span>
<span class="sd">            See `strategies` for acceptable keys.</span>
<span class="sd">        strategies (dict): {str, func} pairs where each key identifies</span>
<span class="sd">            a strategy (in human-readable text) and each value is a</span>
<span class="sd">            function. All functions have the same call signature and</span>
<span class="sd">            return value; this is the call signature of the Strategy</span>
<span class="sd">            object.</span>
<span class="sd">            See each subclass&#39;s documentation for more information on</span>
<span class="sd">            the call signature for the subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
        <span class="c1"># NOTE: `strategy` is required here, but providing a suitable</span>
        <span class="c1"># default value in __init__ of each subclass is recommended.</span>

        <span class="c1"># If the method itself was passed, translate that into the key</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="s1">&#39;strategy_key&#39;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">.</span><span class="n">strategy_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="n">strategy</span>

        <span class="c1"># Check types and values:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Strategy: strategy must be a str&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">strategies</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Strategy: Unsupported strategy &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;value: &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">)</span>

<div class="viewcode-block" id="Strategy.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.Strategy.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Makes the Strategy object callable. &quot;&quot;&quot;</span>
        <span class="c1"># Call the selected strategy method.</span>
        <span class="c1"># The method is unbound (as it&#39;s assigned at the class level) so</span>
        <span class="c1"># technically it&#39;s a function. We must pass `self` explicitly.</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">strategies</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_param_check</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Checks that `var` is not None and is of type(s) var_type. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Strategy: &#39;</span> <span class="o">+</span> <span class="n">var_name</span> <span class="o">+</span> <span class="s1">&#39; is required.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var_type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Strategy: &#39;</span> <span class="o">+</span> <span class="n">var_name</span> <span class="o">+</span> <span class="s1">&#39; must be of &#39;</span> <span class="o">+</span>
                                <span class="s1">&#39;type(s) &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">var_type</span><span class="p">))</span></div>


<div class="viewcode-block" id="ContributionStrategy"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy">[docs]</a><span class="k">class</span> <span class="nc">ContributionStrategy</span><span class="p">(</span><span class="n">Strategy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Determines an annual gross contribution, before reductions.</span>

<span class="sd">    This class is callable. Its call signature has this form:</span>
<span class="sd">    `obj(year, refund, other_contribution, net_income, gross_income)`.</span>
<span class="sd">    Arguments may be omitted if the selected strategy does not require</span>
<span class="sd">    it; otherwise, an error is raised.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strategy (str): A string corresponding to a particular</span>
<span class="sd">            contribution strategy. See `strategies` for acceptable keys.</span>
<span class="sd">        strategies (dict): {str, func} pairs where each key identifies</span>
<span class="sd">            a strategy (in human-readable text) and each value is a</span>
<span class="sd">            function with the same arguments and return value as</span>
<span class="sd">            gross_contribution(). See its documentation for more info.</span>
<span class="sd">            Acceptable keys include:</span>
<span class="sd">                &quot;Constant contribution&quot;</span>
<span class="sd">                &quot;Constant living expenses&quot;</span>
<span class="sd">                &quot;Percentage of gross income&quot;</span>
<span class="sd">                &quot;Percentage of net income&quot;</span>
<span class="sd">        base_amount (Money): A user-supplied amount of money, used in</span>
<span class="sd">            some strategies as a baseline for contributions.</span>
<span class="sd">        rate (Decimal): A user-supplied contribution rate. Must be a</span>
<span class="sd">            percentage (e.g. Decimal(&#39;0.03&#39;) means 3%).</span>
<span class="sd">        refund_reinvestment_rate (Decimal): The percentage of each tax</span>
<span class="sd">            refund that is reinvested in the year it&#39;s received.</span>
<span class="sd">        inflation_adjust (callable): If provided, `base_amount` is</span>
<span class="sd">            interpreted as a real (i.e. inflation-adjusted) currency</span>
<span class="sd">            value. This callable object will be called as</span>
<span class="sd">            `inflation_adjust(year[, base_year])` to receive the</span>
<span class="sd">            inflation-adjustment factor between real and nominal values</span>
<span class="sd">            for that year (relative to base_year, if provided).</span>
<span class="sd">            Optional. If not provided, `base_amount` is not</span>
<span class="sd">            inflation_adjusted.</span>

<span class="sd">    Args:</span>
<span class="sd">        refund (Money): The sum total of tax refunds and other</span>
<span class="sd">            carryforward amounts from previous years. May be</span>
<span class="sd">            fully or partially included in gross contributions,</span>
<span class="sd">            depending on refund_reinvestment_rate.</span>
<span class="sd">        other_contribution (Money): An additional amount to include</span>
<span class="sd">            in the gross contribution (e.g. proceeds from the sale</span>
<span class="sd">            of one&#39;s home)</span>
<span class="sd">        net_income (Money): Net family income for the year.</span>
<span class="sd">        gross_income (Money): Gross family income for the year.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A Money object corresponding to the gross contribution amount</span>
<span class="sd">        for the family for the year.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: A required value was not provided for the given</span>
<span class="sd">            strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-arguments</span>
    <span class="c1"># We need to pass the strategy&#39;s state variables at init time. There</span>
    <span class="c1"># are 6 of them (including self). Refactoring to use a dict or</span>
    <span class="c1"># similar would hurt readability.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">base_amount</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">refund_reinvestment_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">inflation_adjust</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for ContributionStrategy. &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_amount</span> <span class="o">=</span> <span class="n">Money</span><span class="p">(</span><span class="n">base_amount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refund_reinvestment_rate</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">refund_reinvestment_rate</span><span class="p">)</span>

        <span class="c1"># If no inflation_adjustment is specified, create a default</span>
        <span class="c1"># value so that methods don&#39;t need to test for None</span>
        <span class="k">if</span> <span class="n">inflation_adjust</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span> <span class="o">=</span> <span class="n">inflation_adjust</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="mi">1</span>

        <span class="c1"># Types are enforced by explicit conversion; no need to check.</span>

    <span class="c1"># Begin defining subclass-specific strategies</span>
    <span class="c1"># pylint: disable=W0613</span>
<div class="viewcode-block" id="ContributionStrategy.strategy_const_contribution"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy.strategy_const_contribution">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Constant contribution&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_const_contribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contribute a constant amount each year. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Money</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_amount</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">))</span></div>

<div class="viewcode-block" id="ContributionStrategy.strategy_const_living_expenses"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy.strategy_const_living_expenses">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Constant living expenses&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_const_living_expenses</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">net_income</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contribute the money remaining after living expenses. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span>
            <span class="n">net_income</span> <span class="o">-</span> <span class="n">Money</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_amount</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">)),</span>
            <span class="n">Money</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ContributionStrategy.strategy_net_percent"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy.strategy_net_percent">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Percentage of net income&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_net_percent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net_income</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contribute a percentage of net income. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="n">net_income</span></div>

<div class="viewcode-block" id="ContributionStrategy.strategy_gross_percent"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy.strategy_gross_percent">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Percentage of gross income&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_gross_percent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gross_income</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contribute a percentage of gross income. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="n">gross_income</span></div>

<div class="viewcode-block" id="ContributionStrategy.strategy_earnings_percent"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy.strategy_earnings_percent">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Percentage of earnings growth&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_earnings_percent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">net_income</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contribute a percentage of earnings above the base amount. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">net_income</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_amount</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ContributionStrategy.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.ContributionStrategy.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">refund</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">other_contribution</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">net_income</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gross_income</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">retirement_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the gross contribution for the year. &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: We layer on refund and other_contribution amounts on top</span>
        <span class="c1"># of what the underlying strategy dictates.</span>
        <span class="c1"># TODO: Consider reimplementing with list (dict?) arguments for</span>
        <span class="c1"># consistency with WithdrawalStrategy.</span>

        <span class="c1"># We always contribute carryover/refunds/etc:</span>
        <span class="n">contribution</span> <span class="o">=</span> <span class="n">refund</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">refund_reinvestment_rate</span> <span class="o">+</span> \
            <span class="n">other_contribution</span>
        <span class="c1"># Don&#39;t make contributions if we&#39;ve retired:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">retirement_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="n">year</span> <span class="o">&gt;</span> <span class="n">retirement_year</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">contribution</span>
        <span class="c1"># If we&#39;re not yet retired, determine what to contribute:</span>
        <span class="k">return</span> <span class="n">contribution</span> <span class="o">+</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span>
            <span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span> <span class="n">net_income</span><span class="o">=</span><span class="n">net_income</span><span class="p">,</span> <span class="n">gross_income</span><span class="o">=</span><span class="n">gross_income</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="WithdrawalStrategy"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.WithdrawalStrategy">[docs]</a><span class="k">class</span> <span class="nc">WithdrawalStrategy</span><span class="p">(</span><span class="n">Strategy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Determines an annual gross withdrawal.</span>

<span class="sd">    This class is callable. Its call signature has this form:</span>
<span class="sd">    `obj(year, benefits, net_income, gross_income, principal,</span>
<span class="sd">    retirement_year)`.</span>

<span class="sd">    Arguments may be omitted if the selected strategy does not require</span>
<span class="sd">    it; otherwise, an error is raised.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strategy (str, func): Either a string corresponding to a</span>
<span class="sd">            particular strategy or an instance of the strategy itself.</span>
<span class="sd">            See `strategies` for acceptable keys.</span>
<span class="sd">        strategies (dict): {str, func} pairs where each key identifies</span>
<span class="sd">            a strategy (in human-readable text) and each value is a</span>
<span class="sd">            function with the same arguments and return value as</span>
<span class="sd">            gross_contribution(). See its documentation for more info.</span>
<span class="sd">            Acceptable keys include:</span>
<span class="sd">                &quot;Constant withdrawal&quot;</span>
<span class="sd">                &quot;Percentage of principal&quot;</span>
<span class="sd">                &quot;Percentage of gross income&quot;</span>
<span class="sd">                &quot;Percentage of net income&quot;</span>
<span class="sd">        base_amount (Money): A user-supplied amount of money, used in</span>
<span class="sd">            some strategies as a baseline for withdrawals.</span>
<span class="sd">        rate (Decimal): A user-supplied withdrawal rate. Must be a</span>
<span class="sd">            percentage (e.g. Decimal(&#39;0.03&#39;) means 3%).</span>
<span class="sd">        timing (str, Decimal): Withdrawals are modelled as a lump sum</span>
<span class="sd">            which takes place at this time. If you&#39;re using a</span>
<span class="sd">            TransactionStrategy to determine per-account withdrawals,</span>
<span class="sd">            it&#39;s recommended that it use the same timing.</span>
<span class="sd">            This is expressed according to the `when` convention</span>
<span class="sd">            described in `ledger.Account`.</span>
<span class="sd">        inflation_adjust (callable): If provided, `base_amount` is</span>
<span class="sd">            interpreted as a real (i.e. inflation-adjusted) currency</span>
<span class="sd">            value. This callable object will be called as</span>
<span class="sd">            `inflation_adjust(year[, base_year])` to receive the</span>
<span class="sd">            inflation-adjustment factor between real and nominal values</span>
<span class="sd">            for that year (relative to base_year, if provided).</span>
<span class="sd">            Optional. If not provided, `base_amount` is not</span>
<span class="sd">            inflation_adjusted.</span>
<span class="sd">        income_adjusted (bool): If True, withdrawals are reduced to</span>
<span class="sd">            account for income from other sources.</span>

<span class="sd">    Args:</span>
<span class="sd">        year (int): The current year. Optional, but if inflation_adjust</span>
<span class="sd">            requires a year parameter than an error will be raised.</span>
<span class="sd">        benefits (Money): Other income for the year.</span>
<span class="sd">            If `benefits_adjusted` is True, withdrawals will be reduced</span>
<span class="sd">            accordingly to maintain the target living standard.</span>
<span class="sd">        net_income (dict): {year: Money} pairs. Provides the family&#39;s</span>
<span class="sd">            total net income for each year.</span>
<span class="sd">        gross_income (dict): {year: Money} pairs. Provides the family&#39;s</span>
<span class="sd">            total gross income for each year.</span>
<span class="sd">        principal (dict): {year: Money} pairs. Provides the total</span>
<span class="sd">            principal saves for each year.</span>
<span class="sd">        retirement_year (int): The year in which the family retired.</span>
<span class="sd">            Used as a reference date to set withdrawals for some</span>
<span class="sd">            strategies.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A Money object corresponding to the gross withdrawal amount</span>
<span class="sd">        for the family for the year.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: A required value was not provided for the given</span>
<span class="sd">            strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-arguments</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">base_amount</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">timing</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">,</span>
        <span class="n">income_adjusted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">inflation_adjust</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for ContributionStrategy. &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">base_amount</span> <span class="o">=</span> <span class="n">Money</span><span class="p">(</span><span class="n">base_amount</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="n">timing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">income_adjusted</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">income_adjusted</span><span class="p">)</span>

        <span class="c1"># If no inflation_adjustment is specified, create a default</span>
        <span class="c1"># value so that methods don&#39;t need to test for None</span>
        <span class="k">if</span> <span class="n">inflation_adjust</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span> <span class="o">=</span> <span class="n">inflation_adjust</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">,</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;WithdrawalStrategy: timing must be Decimal &#39;</span> <span class="o">+</span>
                            <span class="s1">&#39;or str type.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span> <span class="ow">or</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;WithdrawalStrategy: timing must be </span><span class="se">\&#39;</span><span class="s1">start</span><span class="se">\&#39;</span><span class="s1"> &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;or </span><span class="se">\&#39;</span><span class="s1">end</span><span class="se">\&#39;</span><span class="s1"> if of type str&#39;</span><span class="p">)</span>

    <span class="c1"># Begin defining subclass-specific strategies</span>
    <span class="c1"># pylint: disable=W0613</span>
<div class="viewcode-block" id="WithdrawalStrategy.strategy_const_withdrawal"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.WithdrawalStrategy.strategy_const_withdrawal">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Constant withdrawal&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_const_withdrawal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Withdraw a constant amount each year. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Money</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_amount</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">))</span></div>

<div class="viewcode-block" id="WithdrawalStrategy.strategy_principal_percent"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.WithdrawalStrategy.strategy_principal_percent">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Percentage of principal&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_principal_percent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">principal_history</span><span class="p">,</span> <span class="n">retirement_year</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Withdraw a percentage of principal (as of retirement). &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="n">principal_history</span><span class="p">[</span><span class="n">retirement_year</span><span class="p">]</span> <span class="o">*</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">retirement_year</span><span class="p">)</span></div>

<div class="viewcode-block" id="WithdrawalStrategy.strategy_net_percent"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.WithdrawalStrategy.strategy_net_percent">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Percentage of net income&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_net_percent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">net_income_history</span><span class="p">,</span> <span class="n">retirement_year</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Withdraw a percentage of max. net income (as of retirement). &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="n">net_income_history</span><span class="p">[</span><span class="n">retirement_year</span><span class="p">]</span> <span class="o">*</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">retirement_year</span><span class="p">)</span></div>

<div class="viewcode-block" id="WithdrawalStrategy.strategy_gross_percent"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.WithdrawalStrategy.strategy_gross_percent">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Percentage of gross income&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_gross_percent</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">gross_income_history</span><span class="p">,</span> <span class="n">retirement_year</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Withdraw a percentage of gross income. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">*</span> <span class="n">gross_income_history</span><span class="p">[</span><span class="n">retirement_year</span><span class="p">]</span> <span class="o">*</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">inflation_adjust</span><span class="p">(</span><span class="n">year</span><span class="p">,</span> <span class="n">retirement_year</span><span class="p">)</span></div>

    <span class="c1"># TODO: Add another strategy that tweaks the withdrawal rate</span>
    <span class="c1"># periodically (e.g. every 10 years) based on actual portfolio</span>
    <span class="c1"># performance? (This sort of thing is why this class was redesigned</span>
    <span class="c1"># to take dicts as inputs instead of a handful of scalar values.)</span>

<div class="viewcode-block" id="WithdrawalStrategy.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.WithdrawalStrategy.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">other_income</span><span class="o">=</span><span class="n">Money</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="n">net_income_history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gross_income_history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">principal_history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">retirement_year</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the gross withdrawal for the year. &quot;&quot;&quot;</span>
        <span class="c1"># If we&#39;re not yet retired, no withdrawals:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">retirement_year</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
            <span class="n">year</span> <span class="o">&lt;=</span> <span class="n">retirement_year</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">Money</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># First determine what the strategy recommends, before</span>
        <span class="c1"># adjusting for other income.</span>
        <span class="n">strategy_result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span>
            <span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span>
            <span class="n">net_income_history</span><span class="o">=</span><span class="n">net_income_history</span><span class="p">,</span>
            <span class="n">gross_income_history</span><span class="o">=</span><span class="n">gross_income_history</span><span class="p">,</span>
            <span class="n">principal_history</span><span class="o">=</span><span class="n">principal_history</span><span class="p">,</span>
            <span class="n">retirement_year</span><span class="o">=</span><span class="n">retirement_year</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Determine whether to (and how much to) reduce the</span>
        <span class="c1"># withdrawal due to other income:</span>
        <span class="n">income_adjustment</span> <span class="o">=</span> <span class="n">Money</span><span class="p">(</span>
            <span class="n">other_income</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">income_adjusted</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="c1"># We want to deduct other income from the withdrawal amount,</span>
        <span class="c1"># but we don&#39;t want to return a negative value.</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">strategy_result</span> <span class="o">-</span> <span class="n">income_adjustment</span><span class="p">,</span> <span class="n">Money</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="TransactionStrategy"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.TransactionStrategy">[docs]</a><span class="k">class</span> <span class="nc">TransactionStrategy</span><span class="p">(</span><span class="n">Strategy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Determines account-specific transactions.</span>

<span class="sd">    If there are multiple accounts of the same type, the behaviour</span>
<span class="sd">    of this class, when called, is undefined.</span>

<span class="sd">    If any account has a contribution limit that is lower than the</span>
<span class="sd">    weighted amount to be contributed, the excess contribution is</span>
<span class="sd">    redistributed to other accounts using the same strategy.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strategy (str, func): Either a string corresponding to a</span>
<span class="sd">            particular strategy or an instance of the strategy itself.</span>
<span class="sd">            See `strategies` for acceptable keys.</span>
<span class="sd">        strategies (dict): {str, func} pairs where each key identifies</span>
<span class="sd">            a strategy (in human-readable text) and each value is a</span>
<span class="sd">            function with the same arguments and return value as</span>
<span class="sd">            transactions(). See its documentation for more info.</span>
<span class="sd">            Acceptable keys include:</span>
<span class="sd">                &quot;Ordered&quot;</span>
<span class="sd">                &quot;Weighted&quot;</span>
<span class="sd">        weights (dict): {str, weight} pairs, where keys identify account</span>
<span class="sd">            types (as class names, e.g. &#39;RRSP&#39;, &#39;SavingsAccount&#39;) and</span>
<span class="sd">            weight values indicate how much to prioritize the</span>
<span class="sd">            corresponding account.</span>
<span class="sd">        timing (str, Decimal): Transactions are modelled as lump sums</span>
<span class="sd">            which take place at this time.</span>
<span class="sd">            This is expressed according to the `when` convention</span>
<span class="sd">            described in `ledger.Account`.</span>

<span class="sd">    Args:</span>
<span class="sd">        total (Money): The sum of transactions (positive, for</span>
<span class="sd">            contributions, or negative, for withdrawals) across</span>
<span class="sd">            all accounts.</span>
<span class="sd">        accounts (list): Accounts to contribute to/withdraw from.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict of {Account, Money} pairs where each Account object</span>
<span class="sd">        is one of the input accounts and each Money object is a</span>
<span class="sd">        transaction for that account.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">timing</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for TransactionStrategy. &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="n">timing</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;account type (key)&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="c1"># TODO: Check that val is Decimal-convertible instead of</span>
            <span class="c1"># a rigid type check?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span>
                <span class="n">val</span><span class="p">,</span> <span class="s1">&#39;account weight (value)&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># NOTE: We leave it to calling code to interpret str-valued</span>
        <span class="c1"># timing. (We could convert to `When` here - consider it.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">,</span> <span class="s1">&#39;timing&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>

    <span class="c1"># pylint: disable=W0613</span>
<div class="viewcode-block" id="TransactionStrategy.strategy_ordered"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.TransactionStrategy.strategy_ordered">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Ordered&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_ordered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contributes/withdraws in order of account priority.</span>

<span class="sd">        The account with the lowest-valued priority is contributed to</span>
<span class="sd">        (or withdrawn from) first. Thus, if three accounts have weights</span>
<span class="sd">        1, 2, and 3, then account with weight 1 will go first, followed</span>
<span class="sd">        by 2, then 3.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Handle the case where multiple objects of the same type</span>
        <span class="c1"># are passed via `accounts`. (Ideally, treat them as a single</span>
        <span class="c1"># account and split contributions/withdrawals between them in a</span>
        <span class="c1"># reasonable way; e.g. proportional to current balance)</span>

        <span class="c1"># Build a dict of {Account, weight} pairs</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="p">{</span><span class="n">account</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">account</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
                 <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span>
                 <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">account</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">}</span>
        <span class="c1"># Build a sorted list based on the above pairings</span>
        <span class="n">accounts_ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">adict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">adict</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>

        <span class="c1"># Build a dummy dict that we&#39;ll fill with values to return</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="p">{</span><span class="n">account</span><span class="p">:</span> <span class="n">Money</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span><span class="p">}</span>

        <span class="c1"># Now fill up (or drain) the accounts in order of priority</span>
        <span class="c1"># until we hit the total.</span>
        <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts_ordered</span><span class="p">:</span>
            <span class="c1"># First, determine the largest possible contribution/withdrawal</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">account</span><span class="o">.</span><span class="n">max_outflow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">))</span> \
                <span class="k">if</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">account</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">())</span>
            <span class="c1"># Allocate that amount and reduce total remaining to be allocated</span>
            <span class="n">transactions</span><span class="p">[</span><span class="n">account</span><span class="p">]</span> <span class="o">=</span> <span class="n">transaction</span>
            <span class="n">total</span> <span class="o">-=</span> <span class="n">transaction</span>

        <span class="k">return</span> <span class="n">transactions</span></div>

    <span class="c1"># pylint: disable=W0613</span>
<div class="viewcode-block" id="TransactionStrategy.strategy_weighted"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.TransactionStrategy.strategy_weighted">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Weighted&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Contributes to/withdraws from all accounts based on weights. &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Handle the case where multiple objects of the same type</span>
        <span class="c1"># are passed via `accounts`. (Ideally, treat them as a single</span>
        <span class="c1"># account and split contributions/withdrawals between them in a</span>
        <span class="c1"># reasonable way; e.g. proportional to current balance)</span>

        <span class="c1"># Due to recursion, there&#39;s no guarantee that weights will sum</span>
        <span class="c1"># to 1, so we&#39;ll need to normalize weights.</span>
        <span class="n">normalization</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">account</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span><span class="p">])</span>

        <span class="n">transactions</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Determine per-account contributions based on the weight:</span>
        <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span><span class="p">:</span>
            <span class="n">transactions</span><span class="p">[</span><span class="n">account</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span> <span class="o">*</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">account</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">/</span> <span class="n">normalization</span>

        <span class="k">return</span> <span class="n">transactions</span></div>

    <span class="k">def</span> <span class="nf">_recurse_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Recursively assigns minimum inflows/outflows to accounts. &quot;&quot;&quot;</span>
        <span class="c1"># Check to see whether any accounts have minimum inflows or</span>
        <span class="c1"># outflows that aren&#39;t met by the allocation in `transactions`.</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># For inflows, check min_inflow and max_inflow</span>
            <span class="n">override_accounts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">account</span><span class="p">:</span> <span class="n">account</span><span class="o">.</span><span class="n">min_inflow</span><span class="p">()</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">transactions</span>
                <span class="k">if</span> <span class="n">account</span><span class="o">.</span><span class="n">min_inflow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">transactions</span><span class="p">[</span><span class="n">account</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For outflows, check min_outflow.</span>
            <span class="c1"># (Recall that outflows are negative-valued)</span>
            <span class="n">override_accounts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">account</span><span class="p">:</span> <span class="n">account</span><span class="o">.</span><span class="n">min_outflow</span><span class="p">()</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">transactions</span>
                <span class="k">if</span> <span class="n">account</span><span class="o">.</span><span class="n">min_outflow</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">transactions</span><span class="p">[</span><span class="n">account</span><span class="p">]</span>
            <span class="p">}</span>

        <span class="c1"># If there are no accounts that need to be tweaked, we&#39;re done.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">override_accounts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transactions</span>

        <span class="c1"># If we found some such accounts, set their transaction amounts</span>
        <span class="c1"># manually and recurse onto the remaining accounts.</span>

        <span class="c1"># First, manually add the minimum transaction amounts to the</span>
        <span class="c1"># identified accounts:</span>
        <span class="n">transactions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">override_accounts</span><span class="p">)</span>
        <span class="c1"># Identify all accounts that haven&#39;t been manually set yet:</span>
        <span class="n">remaining_accounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">account</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span>
                              <span class="k">if</span> <span class="n">account</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">override_accounts</span><span class="p">]</span>

        <span class="c1"># Determine the amount remaining to be allocated:</span>
        <span class="n">remaining_total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">override_accounts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># If we&#39;ve already allocated more than the original total</span>
        <span class="c1"># (just on the overridden accounts!) then there&#39;s no room left</span>
        <span class="c1"># to recurse on the strategy. Simply allocate the minimum</span>
        <span class="c1"># inflow/outflow for each remaining accounts and terminate:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remaining_total</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">total</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remaining_total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="n">remaining_total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Inflows</span>
                <span class="n">override_accounts</span> <span class="o">=</span> <span class="p">{</span><span class="n">account</span><span class="p">:</span> <span class="n">account</span><span class="o">.</span><span class="n">min_inflow</span><span class="p">()</span>
                                     <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">remaining_accounts</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Outflows</span>
                <span class="n">override_accounts</span> <span class="o">=</span> <span class="p">{</span><span class="n">account</span><span class="p">:</span> <span class="n">account</span><span class="o">.</span><span class="n">min_outflow</span><span class="p">()</span>
                                     <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">remaining_accounts</span><span class="p">}</span>
            <span class="n">transactions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">override_accounts</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">transactions</span>

        <span class="c1"># Otherwise, if there&#39;s still money to be allocated,</span>
        <span class="c1"># recurse onto the remaining accounts:</span>
        <span class="n">remaining_transactions</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span>
            <span class="n">total</span><span class="o">=</span><span class="n">remaining_total</span><span class="p">,</span>
            <span class="n">accounts</span><span class="o">=</span><span class="n">remaining_accounts</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">transactions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remaining_transactions</span><span class="p">)</span>

        <span class="c1"># Now recurse to ensure that non of the non-maxed accounts have</span>
        <span class="c1"># exceeded their max after applying the strategy.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_min</span><span class="p">(</span>
            <span class="n">remaining_total</span><span class="p">,</span> <span class="n">remaining_accounts</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_recurse_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Recursively assigns minimum inflows/outflows to accounts. &quot;&quot;&quot;</span>
        <span class="c1"># Check to see whether any accounts have minimum inflows or</span>
        <span class="c1"># outflows that aren&#39;t met by the allocation in `transactions`.</span>
        <span class="k">if</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># For inflows, check min_inflow and max_inflow</span>
            <span class="n">override_accounts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">account</span><span class="p">:</span> <span class="n">account</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">()</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">transactions</span>
                <span class="k">if</span> <span class="n">account</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">transactions</span><span class="p">[</span><span class="n">account</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For outflows, check max_outflow.</span>
            <span class="c1"># (Recall that outflows are negative-valued)</span>
            <span class="n">override_accounts</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">account</span><span class="p">:</span> <span class="n">account</span><span class="o">.</span><span class="n">max_outflow</span><span class="p">()</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">transactions</span>
                <span class="k">if</span> <span class="n">account</span><span class="o">.</span><span class="n">max_outflow</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">transactions</span><span class="p">[</span><span class="n">account</span><span class="p">]</span>
            <span class="p">}</span>

        <span class="c1"># If there are no accounts that need to be tweaked, we&#39;re done.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">override_accounts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transactions</span>

        <span class="c1"># First, manually add the minimum transaction amounts to the</span>
        <span class="c1"># identified accounts:</span>
        <span class="n">transactions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">override_accounts</span><span class="p">)</span>
        <span class="c1"># Identify all accounts that haven&#39;t been manually set yet:</span>
        <span class="n">remaining_accounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">account</span> <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span>
                              <span class="k">if</span> <span class="n">account</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">override_accounts</span><span class="p">]</span>

        <span class="c1"># Determine the amount to be allocated to the non-maxed accounts:</span>
        <span class="n">remaining_total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">override_accounts</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1"># Reassign money to non-maxed accounts according to the selected</span>
        <span class="c1"># strategy.</span>
        <span class="n">remaining_transactions</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span>
            <span class="n">total</span><span class="o">=</span><span class="n">remaining_total</span><span class="p">,</span>
            <span class="n">accounts</span><span class="o">=</span><span class="n">remaining_accounts</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">transactions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remaining_transactions</span><span class="p">)</span>

        <span class="c1"># Now recurse to ensure that non of the non-maxed accounts have</span>
        <span class="c1"># exceeded their max after applying the strategy.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_max</span><span class="p">(</span>
            <span class="n">remaining_total</span><span class="p">,</span> <span class="n">remaining_accounts</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="TransactionStrategy.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.TransactionStrategy.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a dict of accounts mapped to transactions. &quot;&quot;&quot;</span>
        <span class="c1"># Get an initial proposal for the transactions based on the</span>
        <span class="c1"># selected strategy:</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="o">=</span><span class="n">accounts</span><span class="p">,</span>
                                        <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Recursively ensure that minimum in/outflows are respected:</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_min</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span>
                                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Recursively ensure that maximum in/outflows are respected:</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurse_max</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">accounts</span><span class="p">,</span> <span class="n">transactions</span><span class="p">,</span>
                                         <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transactions</span></div></div>


<div class="viewcode-block" id="RateFunction"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.RateFunction">[docs]</a><span class="k">class</span> <span class="nc">RateFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A callable object with accessible state attributes. &quot;&quot;&quot;</span>

    <span class="c1"># We do provide public methods, but they&#39;re overrides of magic</span>
    <span class="c1"># methods (init and call). Anyways, the purpose of this class is</span>
    <span class="c1"># to expose its state (which a method/function/lambda does not do).</span>
    <span class="c1"># pylint: disable=too-few-public-methods</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scenario</span><span class="p">,</span> <span class="n">person</span><span class="p">,</span> <span class="n">allocation_strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Inits the RateFunction object. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="n">scenario</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">person</span> <span class="o">=</span> <span class="n">person</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocation_strategy</span> <span class="o">=</span> <span class="n">allocation_strategy</span>

<div class="viewcode-block" id="RateFunction.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.RateFunction.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">year</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Rate of return for `year` based on asset allocation.</span>

<span class="sd">        Args:</span>
<span class="sd">            year (int): The year for which the rate of return will be</span>
<span class="sd">                determined.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Decimal: The rate of return. For example, `Decimal(&#39;0.05&#39;)`</span>
<span class="sd">            means a 5% return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allocation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocation_strategy</span><span class="p">(</span>
            <span class="n">age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="p">(</span><span class="n">year</span><span class="p">),</span>
            <span class="n">retirement_age</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">person</span><span class="o">.</span><span class="n">retirement_age</span>
        <span class="p">)</span>
        <span class="c1"># Extract stocks/bonds/other returns:</span>
        <span class="k">if</span> <span class="s1">&#39;stocks&#39;</span> <span class="ow">in</span> <span class="n">allocation</span><span class="p">:</span>
            <span class="n">stocks</span> <span class="o">=</span> <span class="n">allocation</span><span class="p">[</span><span class="s1">&#39;stocks&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stocks</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;bonds&#39;</span> <span class="ow">in</span> <span class="n">allocation</span><span class="p">:</span>
            <span class="n">bonds</span> <span class="o">=</span> <span class="n">allocation</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bonds</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;other&#39;</span> <span class="ow">in</span> <span class="n">allocation</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">allocation</span><span class="p">[</span><span class="s1">&#39;other&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Weight the returns of the various asset classes by each</span>
        <span class="c1"># class&#39;s allocation:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">stocks</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">stock_return</span><span class="p">[</span><span class="n">year</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">bonds</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">bond_return</span><span class="p">[</span><span class="n">year</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">other_return</span><span class="p">[</span><span class="n">year</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">stocks</span> <span class="o">+</span> <span class="n">bonds</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="AllocationStrategy"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.AllocationStrategy">[docs]</a><span class="k">class</span> <span class="nc">AllocationStrategy</span><span class="p">(</span><span class="n">Strategy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates an asset allocation for a point in time. Callable.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strategy (str, func): Either a string corresponding to a</span>
<span class="sd">            particular strategy or an instance of the strategy itself.</span>
<span class="sd">            See `strategies` for acceptable keys.</span>
<span class="sd">        strategies (dict): {str, func} pairs where each key identifies</span>
<span class="sd">            a strategy (in human-readable text) and each value is a</span>
<span class="sd">            function with the same arguments and return value as</span>
<span class="sd">            transactions(). See its documentation for more info.</span>
<span class="sd">            Acceptable keys include:</span>
<span class="sd">                &quot;n-age&quot;</span>
<span class="sd">                &quot;Transition to constant&quot;</span>
<span class="sd">        min_equity (Decimal): The minimum percentage of a portfolio that</span>
<span class="sd">            may be invested in equities. (All non-equity investments</span>
<span class="sd">            are included in `fixed_income`)</span>
<span class="sd">        max_equity (Decimal): The maximum percentage of a portfolio that</span>
<span class="sd">            may be invested in equities.</span>
<span class="sd">        target (Decimal): A target value used by strategies to affect</span>
<span class="sd">            their behaviour.</span>
<span class="sd">            For example, for the `n-age` strategy, this is the value `n`</span>
<span class="sd">            (e.g. `target=100` -&gt; `100-age`).</span>
<span class="sd">            For the `Transition to constant` strategy, this is the</span>
<span class="sd">            percentage of equities to transition to (e.g. for</span>
<span class="sd">            `Transition to 50-50`, use `Decimal(&#39;0.5&#39;)`)</span>
<span class="sd">        standard_retirement_age (int): The typical retirement age used</span>
<span class="sd">            in retirement planning. This is used if</span>
<span class="sd">            adjust_for_retirement_plan is False, otherwise the actual</span>
<span class="sd">            (estimated) retirement age for the person is used.</span>
<span class="sd">        risk_transition_period (int): The period of time over which the</span>
<span class="sd">            `Transition to constant` strategy transitions. For example,</span>
<span class="sd">            if set to 20, the strategy will transition from max_equity</span>
<span class="sd">            to transition_strategy_target over 20 years, ending on the</span>
<span class="sd">            retirement date.</span>
<span class="sd">        adjust_for_retirement_plan (bool): If True, the allocation will</span>
<span class="sd">            be adjusted to increase risk for later retirement or</span>
<span class="sd">            decrease risk for later retirement. If False, the standard</span>
<span class="sd">            retirement age will be used.</span>

<span class="sd">    Args:</span>
<span class="sd">        age (int): The current age of the plannee.</span>
<span class="sd">        retirement_age (int): The (estimated) retirement age of the</span>
<span class="sd">            plannee.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict[str, Decimal]: `{asset: allocation}` pairs, where `asset`</span>
<span class="sd">        is a string in `{&#39;stocks&#39;, &#39;bonds&#39;}` and `allocation` is the</span>
<span class="sd">        percentage of a portfolio that is made up of that asset class.</span>
<span class="sd">        Allocations sum to 1 (e.g. `Decimal(0.03` means 3%).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=too-many-arguments</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">min_equity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_equity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">standard_retirement_age</span><span class="o">=</span><span class="mi">65</span><span class="p">,</span> <span class="n">risk_transition_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">adjust_for_retirement_plan</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for AllocationStrategy. &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_equity</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">min_equity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_equity</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">max_equity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standard_retirement_age</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">standard_retirement_age</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">risk_transition_period</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">risk_transition_period</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjust_for_retirement_plan</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">adjust_for_retirement_plan</span><span class="p">)</span>

        <span class="c1"># All of the above are type-converted; no need to check types!</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_equity</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_equity</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;AllocationStrategy: min_equity must not be &#39;</span> <span class="o">+</span>
                             <span class="s1">&#39;greater than max_equity.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="AllocationStrategy.strategy_n_minus_age"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.AllocationStrategy.strategy_n_minus_age">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;n-age&#39;</span><span class="p">)</span>
    <span class="c1"># pylint: disable=W0613</span>
    <span class="k">def</span> <span class="nf">strategy_n_minus_age</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">retirement_age</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Used for 100-age, 110-age, 125-age, etc. strategies. &quot;&quot;&quot;</span>
        <span class="c1"># If we&#39;re adjusting for early/late retirement,</span>
        <span class="c1"># pretend we&#39;re a few years younger if we&#39;re retiring later</span>
        <span class="c1"># (or that we&#39;re older if retiring earlier)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjust_for_retirement_plan</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="n">retirement_age</span><span class="p">,</span> <span class="s1">&#39;retirement age&#39;</span><span class="p">)</span>
            <span class="n">age</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_retirement_age</span> <span class="o">-</span> <span class="n">retirement_age</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">retirement_age</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_retirement_age</span>
        <span class="c1"># The formula for `n-age` is just that (recall that</span>
        <span class="c1"># n=constant_strategy_target). Insert the adjustment factor too.</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">-</span> <span class="n">age</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
        <span class="c1"># Ensure that we don&#39;t move past our min/max equities</span>
        <span class="n">target</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_equity</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_equity</span><span class="p">)</span>
        <span class="c1"># Bonds is simply whatever isn&#39;t in equities</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;stocks&#39;</span><span class="p">:</span> <span class="n">target</span><span class="p">,</span> <span class="s1">&#39;bonds&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">target</span><span class="p">}</span></div>

<div class="viewcode-block" id="AllocationStrategy.strategy_transition_to_const"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.AllocationStrategy.strategy_transition_to_const">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Transition to constant&#39;</span><span class="p">)</span>
    <span class="c1"># pylint: disable=W0613</span>
    <span class="k">def</span> <span class="nf">strategy_transition_to_const</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">retirement_age</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Used for `Transition to 50-50`, `Transition to 70-30`, etc. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
        <span class="c1"># Assume we&#39;re retiring at the standard retirement age unless</span>
        <span class="c1"># adjust_for_retirement_plan is True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjust_for_retirement_plan</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="n">retirement_age</span><span class="p">,</span> <span class="s1">&#39;retirement age&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">retirement_age</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_retirement_age</span>

        <span class="c1"># If retirement is outside our risk transition window (e.g. if</span>
        <span class="c1"># it&#39;s more than 20 years away), maximize stock holdings.</span>
        <span class="k">if</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="n">retirement_age</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">risk_transition_period</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;stocks&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_equity</span><span class="p">,</span> <span class="s1">&#39;bonds&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_equity</span><span class="p">}</span>
        <span class="c1"># If we&#39;ve hit retirement, keep equity allocation constant at</span>
        <span class="c1"># our target</span>
        <span class="k">elif</span> <span class="n">age</span> <span class="o">&gt;=</span> <span class="n">retirement_age</span><span class="p">:</span>
            <span class="n">min_equity</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_equity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;stocks&#39;</span><span class="p">:</span> <span class="n">min_equity</span><span class="p">,</span> <span class="s1">&#39;bonds&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">min_equity</span><span class="p">}</span>
        <span class="c1"># Otherwise, smoothly move from max_equity to target over</span>
        <span class="c1"># the risk_transition_period</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">+</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_equity</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="p">)</span> <span class="o">*</span> \
            <span class="p">(</span><span class="n">retirement_age</span> <span class="o">-</span> <span class="n">age</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">risk_transition_period</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;stocks&#39;</span><span class="p">:</span> <span class="n">target</span><span class="p">,</span> <span class="s1">&#39;bonds&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">target</span><span class="p">}</span></div>

<div class="viewcode-block" id="AllocationStrategy.rate_function"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.AllocationStrategy.rate_function">[docs]</a>    <span class="k">def</span> <span class="nf">rate_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">person</span><span class="p">,</span> <span class="n">scenario</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; A rate function usable by Person or Account objects.</span>

<span class="sd">        Args:</span>
<span class="sd">            person (Person): A person. The method builds a portfolio for</span>
<span class="sd">                the person based on this object&#39;s allocation strategy</span>
<span class="sd">                (in particular, based on the person&#39;s age and/or</span>
<span class="sd">                projected retirement date).</span>
<span class="sd">            scenario (Scenario): A scenario providing information on</span>
<span class="sd">                returns on investment for stocks, bonds, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An object callable with the form</span>
<span class="sd">            `rate_function(year) -&gt; Decimal` that provides a rate of</span>
<span class="sd">            return for a given year based on the person&#39;s age and the</span>
<span class="sd">            investment returns for various asset classes provided by</span>
<span class="sd">            `scenario`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to return an object rather than a function or lambda</span>
        <span class="c1"># because we need Forecaster to be able to swap out any of those</span>
        <span class="c1"># attributes when running a forecast.</span>
        <span class="k">return</span> <span class="n">RateFunction</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="n">person</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="AllocationStrategy.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.AllocationStrategy.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">retirement_age</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a dict of {account, Money} pairs. &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Move min_equity and max_equity logic here to simplify</span>
        <span class="c1"># the logic of each strategy.</span>
        <span class="c1"># In the meantime, suppress Pylint&#39;s complaints about how this</span>
        <span class="c1"># method is useless:</span>
        <span class="c1"># pylint: disable=useless-super-delegation</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="n">retirement_age</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DebtPaymentStrategy"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.DebtPaymentStrategy">[docs]</a><span class="k">class</span> <span class="nc">DebtPaymentStrategy</span><span class="p">(</span><span class="n">Strategy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Determines payments for a group of debts.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        strategy (str, func): Either a string corresponding to a</span>
<span class="sd">            particular strategy or an instance of the strategy itself.</span>
<span class="sd">            See `strategies` for acceptable keys.</span>
<span class="sd">        strategies (dict): {str, func} pairs where each key identifies</span>
<span class="sd">            a strategy (in human-readable text) and each value is a</span>
<span class="sd">            function with the same arguments and return value as</span>
<span class="sd">            transactions(). See its documentation for more info.</span>
<span class="sd">            Acceptable keys include:</span>
<span class="sd">                &quot;Snowball&quot;</span>
<span class="sd">                &quot;Avalanche&quot;</span>
<span class="sd">        timing (str, Decimal): Transactions are modelled as lump sums</span>
<span class="sd">            which take place at this time.</span>
<span class="sd">            This is expressed according to the `when` convention</span>
<span class="sd">            described in `ledger.Account`.</span>

<span class="sd">    Args:</span>
<span class="sd">        available (Money): The total amount available for repayment</span>
<span class="sd">            across all accounts.</span>
<span class="sd">        debts (list): Debts to repay.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dict of {Debt, Money} pairs where each Debt object</span>
<span class="sd">        is one of the input accounts and each Money object is a</span>
<span class="sd">        transaction for that account.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">timing</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor for DebtPaymentStrategy. &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">strategy</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timing</span> <span class="o">=</span> <span class="n">timing</span>

        <span class="c1"># NOTE: We leave it to calling code to interpret str-valued</span>
        <span class="c1"># timing. (We could convert to `When` here - consider it.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">,</span> <span class="s1">&#39;timing&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>

    <span class="c1"># pylint: disable=W0613</span>
<div class="viewcode-block" id="DebtPaymentStrategy.strategy_snowball"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.DebtPaymentStrategy.strategy_snowball">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Snowball&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_snowball</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">available</span><span class="p">,</span> <span class="n">debts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pays off the smallest debt first. &quot;&quot;&quot;</span>
        <span class="c1"># First, ensure all minimum payments are made.</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">debt</span><span class="p">:</span> <span class="n">debt</span><span class="o">.</span><span class="n">min_inflow</span><span class="p">(</span><span class="n">when</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="n">debts</span>
        <span class="p">}</span>

        <span class="n">available</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">]</span> <span class="o">*</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span>
                         <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="n">debts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">available</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transactions</span>

        <span class="n">accelerated_debts</span> <span class="o">=</span> <span class="p">{</span><span class="n">debt</span> <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="n">debts</span> <span class="k">if</span> <span class="n">debt</span><span class="o">.</span><span class="n">accelerate_payment</span><span class="p">}</span>
        <span class="c1"># Now we increase contributions to any accelerated debts</span>
        <span class="c1"># (non-accelerated debts can just have minimum payments made,</span>
        <span class="c1"># handled above). Here, increase contributions of the smallest</span>
        <span class="c1"># debt first, then the next, and so on until there&#39;s no money</span>
        <span class="c1"># left to allocate to debt repayment:</span>
        <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">accelerated_debts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">balance</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">):</span>
            <span class="c1"># Debts that don&#39;t reduce savings can be ignored - assume</span>
            <span class="c1"># they&#39;re fully repaid in the first year.</span>
            <span class="k">if</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">]</span> <span class="o">=</span> <span class="n">debt</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Payment is either the outstanding balance or the total of</span>
            <span class="c1"># the available money remaining for payments</span>
            <span class="n">payment</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">debt</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">)</span> <span class="o">-</span> <span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">],</span>  <span class="c1"># balance</span>
                <span class="n">available</span> <span class="o">/</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span>  <span class="c1"># money available</span>
            <span class="p">)</span>
            <span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">payment</span>
            <span class="c1"># `available` is at least partially taken from savings;</span>
            <span class="c1"># only deduct that portion of the payment from `available`</span>
            <span class="n">available</span> <span class="o">-=</span> <span class="n">payment</span> <span class="o">*</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span>

        <span class="k">return</span> <span class="n">transactions</span></div>

<div class="viewcode-block" id="DebtPaymentStrategy.strategy_avalanche"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.DebtPaymentStrategy.strategy_avalanche">[docs]</a>    <span class="nd">@strategy_method</span><span class="p">(</span><span class="s1">&#39;Avalanche&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">strategy_avalanche</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">available</span><span class="p">,</span> <span class="n">debts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Pays off the highest-interest debt first. &quot;&quot;&quot;</span>
        <span class="c1"># First, ensure all minimum payments are made.</span>
        <span class="n">transactions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">debt</span><span class="p">:</span> <span class="n">debt</span><span class="o">.</span><span class="n">min_inflow</span><span class="p">(</span><span class="n">when</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="n">debts</span>
        <span class="p">}</span>

        <span class="n">available</span> <span class="o">-=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">]</span> <span class="o">*</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span>
                         <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="n">debts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">available</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">transactions</span>

        <span class="n">accelerated_debts</span> <span class="o">=</span> <span class="p">{</span><span class="n">debt</span> <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="n">debts</span> <span class="k">if</span> <span class="n">debt</span><span class="o">.</span><span class="n">accelerate_payment</span><span class="p">}</span>
        <span class="c1"># Now we increase contributions to any accelerated debts</span>
        <span class="c1"># (non-accelerated debts can just have minimum payments made,</span>
        <span class="c1"># handled above). Here, increase contributions of the largest</span>
        <span class="c1"># rate first, then the next, and so on until there&#39;s no money</span>
        <span class="c1"># left to allocate to debt repayment:</span>
        <span class="k">for</span> <span class="n">debt</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">accelerated_debts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">rate</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">):</span>
            <span class="c1"># Debts that don&#39;t reduce savings can be ignored - assume</span>
            <span class="c1"># they&#39;re fully repaid in the first year.</span>
            <span class="k">if</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">]</span> <span class="o">=</span> <span class="n">debt</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Payment is either the outstanding balance or the total of</span>
            <span class="c1"># the available money remaining for payments</span>
            <span class="n">payment</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">debt</span><span class="o">.</span><span class="n">max_inflow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timing</span><span class="p">)</span> <span class="o">-</span> <span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">],</span>  <span class="c1"># balance</span>
                <span class="n">available</span> <span class="o">/</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span>  <span class="c1"># money available</span>
            <span class="p">)</span>
            <span class="n">transactions</span><span class="p">[</span><span class="n">debt</span><span class="p">]</span> <span class="o">+=</span> <span class="n">payment</span>
            <span class="c1"># `available` is at least partially taken from savings;</span>
            <span class="c1"># only deduct that portion of the payment from `available`</span>
            <span class="n">available</span> <span class="o">-=</span> <span class="n">payment</span> <span class="o">*</span> <span class="n">debt</span><span class="o">.</span><span class="n">reduction_rate</span>

        <span class="k">return</span> <span class="n">transactions</span></div>

    <span class="c1"># Overriding __call__ solely for intellisense purposes.</span>
    <span class="c1"># pylint: disable=W0235</span>
<div class="viewcode-block" id="DebtPaymentStrategy.__call__"><a class="viewcode-back" href="../../forecaster.strategy.html#forecaster.strategy.DebtPaymentStrategy.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">available</span><span class="p">,</span> <span class="n">debts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a dict of {account, Money} pairs. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">available</span><span class="p">,</span> <span class="n">debts</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Christopher Scott.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>